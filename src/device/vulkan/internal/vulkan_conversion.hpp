/*
 *  Flo's Open libRary (floor)
 *  Copyright (C) 2004 - 2025 Florian Ziesche
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; version 2 of the License only.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#pragma once

#include <floor/core/essentials.hpp>

#if !defined(FLOOR_NO_VULKAN)
#include "vulkan_headers.hpp"
#include <floor/device/graphics_pass.hpp>
#include <floor/device/graphics_pipeline.hpp>

namespace fl {

//! returns the corresponding VkPrimitiveTopology for the specified PRIMITIVE
static inline VkPrimitiveTopology vulkan_primitive_topology_from_primitive(const PRIMITIVE primitive) {
	switch (primitive) {
		case PRIMITIVE::POINT:
			return VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
		case PRIMITIVE::LINE:
			return VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
		case PRIMITIVE::LINE_STRIP:
			return VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
		case PRIMITIVE::TRIANGLE:
			return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		case PRIMITIVE::TRIANGLE_STRIP:
			return VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
	}
}

//! returns the corresponding VkCullModeFlagBits for the specified CULL_MODE
static inline VkCullModeFlagBits vulkan_cull_mode_from_cull_mode(const CULL_MODE cull_mode) {
	switch (cull_mode) {
		case CULL_MODE::NONE:
			return VK_CULL_MODE_NONE;
		case CULL_MODE::BACK:
			return VK_CULL_MODE_BACK_BIT;
		case CULL_MODE::FRONT:
			return VK_CULL_MODE_FRONT_BIT;
	}
}

//! returns the corresponding VkFrontFace for the specified FRONT_FACE
static inline VkFrontFace vulkan_front_face_from_front_face(const FRONT_FACE front_face) {
	switch (front_face) {
		case FRONT_FACE::CLOCKWISE:
			return VK_FRONT_FACE_CLOCKWISE;
		case FRONT_FACE::COUNTER_CLOCKWISE:
			return VK_FRONT_FACE_COUNTER_CLOCKWISE;
	}
}

//! returns the corresponding VkBlendFactor for the specified BLEND_FACTOR
static inline VkBlendFactor vulkan_blend_factor_from_blend_factor(const BLEND_FACTOR blend_factor) {
	switch (blend_factor) {
		case BLEND_FACTOR::ZERO:
			return VK_BLEND_FACTOR_ZERO;
		case BLEND_FACTOR::ONE:
			return VK_BLEND_FACTOR_ONE;
			
		case BLEND_FACTOR::SRC_COLOR:
			return VK_BLEND_FACTOR_SRC_COLOR;
		case BLEND_FACTOR::ONE_MINUS_SRC_COLOR:
			return VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR;
		case BLEND_FACTOR::DST_COLOR:
			return VK_BLEND_FACTOR_DST_COLOR;
		case BLEND_FACTOR::ONE_MINUS_DST_COLOR:
			return VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
			
		case BLEND_FACTOR::SRC_ALPHA:
			return VK_BLEND_FACTOR_SRC_ALPHA;
		case BLEND_FACTOR::ONE_MINUS_SRC_ALPHA:
			return VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
		case BLEND_FACTOR::DST_ALPHA:
			return VK_BLEND_FACTOR_DST_ALPHA;
		case BLEND_FACTOR::ONE_MINUS_DST_ALPHA:
			return VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
		case BLEND_FACTOR::SRC_ALPHA_SATURATE:
			return VK_BLEND_FACTOR_SRC_ALPHA_SATURATE;
			
		case BLEND_FACTOR::BLEND_COLOR:
			return VK_BLEND_FACTOR_CONSTANT_COLOR;
		case BLEND_FACTOR::ONE_MINUS_BLEND_COLOR:
			return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR;
		case BLEND_FACTOR::BLEND_ALPHA:
			return VK_BLEND_FACTOR_CONSTANT_ALPHA;
		case BLEND_FACTOR::ONE_MINUE_BLEND_ALPHA:
			return VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA;
	}
}

//! returns the corresponding VkBlendOp for the specified BLEND_OP
static inline VkBlendOp vulkan_blend_op_from_blend_op(const BLEND_OP blend_op) {
	switch (blend_op) {
		case BLEND_OP::ADD:
			return VK_BLEND_OP_ADD;
		case BLEND_OP::SUB:
			return VK_BLEND_OP_SUBTRACT;
		case BLEND_OP::REV_SUB:
			return VK_BLEND_OP_REVERSE_SUBTRACT;
		case BLEND_OP::MIN:
			return VK_BLEND_OP_MIN;
		case BLEND_OP::MAX:
			return VK_BLEND_OP_MAX;
	}
}

//! returns the corresponding VkCompareOp for the specified DEPTH_COMPARE
static inline VkCompareOp vulkan_compare_op_from_depth_compare(const DEPTH_COMPARE depth_compare) {
	switch (depth_compare) {
		case DEPTH_COMPARE::NEVER:
			return VK_COMPARE_OP_NEVER;
		case DEPTH_COMPARE::LESS:
			return VK_COMPARE_OP_LESS;
		case DEPTH_COMPARE::EQUAL:
			return VK_COMPARE_OP_EQUAL;
		case DEPTH_COMPARE::LESS_OR_EQUAL:
			return VK_COMPARE_OP_LESS_OR_EQUAL;
		case DEPTH_COMPARE::GREATER:
			return VK_COMPARE_OP_GREATER;
		case DEPTH_COMPARE::NOT_EQUAL:
			return VK_COMPARE_OP_NOT_EQUAL;
		case DEPTH_COMPARE::GREATER_OR_EQUAL:
			return VK_COMPARE_OP_GREATER_OR_EQUAL;
		case DEPTH_COMPARE::ALWAYS:
			return VK_COMPARE_OP_ALWAYS;
	}
}

//! returns the corresponding VkIndexType for the specified INDEX_TYPE
static inline VkIndexType vulkan_index_type_from_index_type(const INDEX_TYPE index_type) {
	switch (index_type) {
		case INDEX_TYPE::UINT:
			return VK_INDEX_TYPE_UINT32;
		case INDEX_TYPE::USHORT:
			return VK_INDEX_TYPE_UINT16;
	}
}

//! returns the corresponding VkAttachmentLoadOp for the specified LOAD_OP
static inline VkAttachmentLoadOp vulkan_load_op_from_load_op(const LOAD_OP load_op) {
	switch (load_op) {
		case LOAD_OP::LOAD:
			return VK_ATTACHMENT_LOAD_OP_LOAD;
		case LOAD_OP::CLEAR:
			return VK_ATTACHMENT_LOAD_OP_CLEAR;
		case LOAD_OP::DONT_CARE:
			return VK_ATTACHMENT_LOAD_OP_DONT_CARE;
	}
}

//! returns the corresponding VkAttachmentStoreOp for the specified STORE_OP
static inline VkAttachmentStoreOp vulkan_store_op_from_store_op(const STORE_OP store_op) {
	switch (store_op) {
		case STORE_OP::STORE:
		case STORE_OP::STORE_AND_RESOLVE:
			return VK_ATTACHMENT_STORE_OP_STORE;
		case STORE_OP::RESOLVE:
		case STORE_OP::DONT_CARE:
			return VK_ATTACHMENT_STORE_OP_DONT_CARE;
	}
}

//! returns the corresponding VkFormat for the specified IMAGE_TYPE, return empty if there is no matching format
static inline std::optional<VkFormat> vulkan_format_from_image_type(const IMAGE_TYPE image_type) {
	static const std::unordered_map<IMAGE_TYPE, VkFormat> format_lut {
		// R
		{ IMAGE_TYPE::R8UI_NORM, VK_FORMAT_R8_UNORM },
		{ IMAGE_TYPE::R8I_NORM, VK_FORMAT_R8_SNORM },
		{ IMAGE_TYPE::R8UI, VK_FORMAT_R8_UINT },
		{ IMAGE_TYPE::R8I, VK_FORMAT_R8_SINT },
		{ IMAGE_TYPE::R16UI_NORM, VK_FORMAT_R16_UNORM },
		{ IMAGE_TYPE::R16I_NORM, VK_FORMAT_R16_SNORM },
		{ IMAGE_TYPE::R16UI, VK_FORMAT_R16_UINT },
		{ IMAGE_TYPE::R16I, VK_FORMAT_R16_SINT },
		{ IMAGE_TYPE::R16F, VK_FORMAT_R16_SFLOAT },
		{ IMAGE_TYPE::R32UI, VK_FORMAT_R32_UINT },
		{ IMAGE_TYPE::R32I, VK_FORMAT_R32_SINT },
		{ IMAGE_TYPE::R32F, VK_FORMAT_R32_SFLOAT },
		// RG
		{ IMAGE_TYPE::RG8UI_NORM, VK_FORMAT_R8G8_UNORM },
		{ IMAGE_TYPE::RG8I_NORM, VK_FORMAT_R8G8_SNORM },
		{ IMAGE_TYPE::RG8UI, VK_FORMAT_R8G8_UINT },
		{ IMAGE_TYPE::RG8I, VK_FORMAT_R8G8_SINT },
		{ IMAGE_TYPE::RG16UI_NORM, VK_FORMAT_R16G16_UNORM },
		{ IMAGE_TYPE::RG16I_NORM, VK_FORMAT_R16G16_SNORM },
		{ IMAGE_TYPE::RG16UI, VK_FORMAT_R16G16_UINT },
		{ IMAGE_TYPE::RG16I, VK_FORMAT_R16G16_SINT },
		{ IMAGE_TYPE::RG16F, VK_FORMAT_R16G16_SFLOAT },
		{ IMAGE_TYPE::RG32UI, VK_FORMAT_R32G32_UINT },
		{ IMAGE_TYPE::RG32I, VK_FORMAT_R32G32_SINT },
		{ IMAGE_TYPE::RG32F, VK_FORMAT_R32G32_SFLOAT },
#if 0 // 3-channel formats are not supported by AMD and NVIDIA, so always use 4-channel formats instead
		// TODO: do this dynamically
		// RGB
		{ IMAGE_TYPE::RGB8UI_NORM, VK_FORMAT_R8G8B8_UNORM },
		{ IMAGE_TYPE::RGB8I_NORM, VK_FORMAT_R8G8B8_SNORM },
		{ IMAGE_TYPE::RGB8UI, VK_FORMAT_R8G8B8_UINT },
		{ IMAGE_TYPE::RGB8I, VK_FORMAT_R8G8B8_SINT },
		{ IMAGE_TYPE::RGB16UI_NORM, VK_FORMAT_R16G16B16_UNORM },
		{ IMAGE_TYPE::RGB16I_NORM, VK_FORMAT_R16G16B16_SNORM },
		{ IMAGE_TYPE::RGB16UI, VK_FORMAT_R16G16B16_UINT },
		{ IMAGE_TYPE::RGB16I, VK_FORMAT_R16G16B16_SINT },
		{ IMAGE_TYPE::RGB16F, VK_FORMAT_R16G16B16_SFLOAT },
		{ IMAGE_TYPE::RGB32UI, VK_FORMAT_R32G32B32_UINT },
		{ IMAGE_TYPE::RGB32I, VK_FORMAT_R32G32B32_SINT },
		{ IMAGE_TYPE::RGB32F, VK_FORMAT_R32G32B32_SFLOAT },
		// BGR
		{ IMAGE_TYPE::BGR8UI_NORM, VK_FORMAT_B8G8R8_UNORM },
		{ IMAGE_TYPE::BGR8I_NORM, VK_FORMAT_B8G8R8_SNORM },
		{ IMAGE_TYPE::BGR8UI, VK_FORMAT_B8G8R8_UINT },
		{ IMAGE_TYPE::BGR8I, VK_FORMAT_B8G8R8_SINT },
#else
		// RGB
		{ IMAGE_TYPE::RGB8UI_NORM, VK_FORMAT_R8G8B8A8_UNORM },
		{ IMAGE_TYPE::RGB8I_NORM, VK_FORMAT_R8G8B8A8_SNORM },
		{ IMAGE_TYPE::RGB8UI, VK_FORMAT_R8G8B8A8_UINT },
		{ IMAGE_TYPE::RGB8I, VK_FORMAT_R8G8B8A8_SINT },
		{ IMAGE_TYPE::RGB16UI_NORM, VK_FORMAT_R16G16B16A16_UNORM },
		{ IMAGE_TYPE::RGB16I_NORM, VK_FORMAT_R16G16B16A16_SNORM },
		{ IMAGE_TYPE::RGB16UI, VK_FORMAT_R16G16B16A16_UINT },
		{ IMAGE_TYPE::RGB16I, VK_FORMAT_R16G16B16A16_SINT },
		{ IMAGE_TYPE::RGB16F, VK_FORMAT_R16G16B16A16_SFLOAT },
		{ IMAGE_TYPE::RGB32UI, VK_FORMAT_R32G32B32A32_UINT },
		{ IMAGE_TYPE::RGB32I, VK_FORMAT_R32G32B32A32_SINT },
		{ IMAGE_TYPE::RGB32F, VK_FORMAT_R32G32B32A32_SFLOAT },
		// BGR
		{ IMAGE_TYPE::BGR8UI_NORM, VK_FORMAT_B8G8R8A8_UNORM },
		{ IMAGE_TYPE::BGR8I_NORM, VK_FORMAT_B8G8R8A8_SNORM },
		{ IMAGE_TYPE::BGR8UI, VK_FORMAT_B8G8R8A8_UINT },
		{ IMAGE_TYPE::BGR8I, VK_FORMAT_B8G8R8A8_SINT },
#endif
		// RGB
		{ IMAGE_TYPE::RG11B10F, VK_FORMAT_B10G11R11_UFLOAT_PACK32 },
		{ IMAGE_TYPE::RGB9E5F, VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 },
		// RGBA
		{ IMAGE_TYPE::RGBA8UI_NORM, VK_FORMAT_R8G8B8A8_UNORM },
		{ IMAGE_TYPE::RGBA8I_NORM, VK_FORMAT_R8G8B8A8_SNORM },
		{ IMAGE_TYPE::RGBA8UI, VK_FORMAT_R8G8B8A8_UINT },
		{ IMAGE_TYPE::RGBA8I, VK_FORMAT_R8G8B8A8_SINT },
		{ IMAGE_TYPE::RGBA8UI_NORM | IMAGE_TYPE::FLAG_SRGB, VK_FORMAT_R8G8B8A8_SRGB },
		{ IMAGE_TYPE::RGBA16UI_NORM, VK_FORMAT_R16G16B16A16_UNORM },
		{ IMAGE_TYPE::RGBA16I_NORM, VK_FORMAT_R16G16B16A16_SNORM },
		{ IMAGE_TYPE::RGBA16UI, VK_FORMAT_R16G16B16A16_UINT },
		{ IMAGE_TYPE::RGBA16I, VK_FORMAT_R16G16B16A16_SINT },
		{ IMAGE_TYPE::RGBA16F, VK_FORMAT_R16G16B16A16_SFLOAT },
		{ IMAGE_TYPE::RGBA32UI, VK_FORMAT_R32G32B32A32_UINT },
		{ IMAGE_TYPE::RGBA32I, VK_FORMAT_R32G32B32A32_SINT },
		{ IMAGE_TYPE::RGBA32F, VK_FORMAT_R32G32B32A32_SFLOAT },
		// BGRA
		{ IMAGE_TYPE::BGRA8UI_NORM, VK_FORMAT_B8G8R8A8_UNORM },
		{ IMAGE_TYPE::BGRA8I_NORM, VK_FORMAT_B8G8R8A8_SNORM },
		{ IMAGE_TYPE::BGRA8UI, VK_FORMAT_B8G8R8A8_UINT },
		{ IMAGE_TYPE::BGRA8I, VK_FORMAT_B8G8R8A8_SINT },
		{ IMAGE_TYPE::BGRA8UI_NORM | IMAGE_TYPE::FLAG_SRGB, VK_FORMAT_B8G8R8A8_SRGB },
		// ABGR
		{ IMAGE_TYPE::ABGR8UI_NORM, VK_FORMAT_A8B8G8R8_UNORM_PACK32 },
		{ IMAGE_TYPE::ABGR8I_NORM, VK_FORMAT_A8B8G8R8_SNORM_PACK32 },
		{ IMAGE_TYPE::ABGR8UI, VK_FORMAT_A8B8G8R8_UINT_PACK32 },
		{ IMAGE_TYPE::ABGR8I, VK_FORMAT_A8B8G8R8_SINT_PACK32 },
		{ IMAGE_TYPE::A2BGR10UI_NORM, VK_FORMAT_A2B10G10R10_UNORM_PACK32 },
		{ IMAGE_TYPE::A2BGR10UI, VK_FORMAT_A2B10G10R10_UINT_PACK32 },
		// ARGB
		{ IMAGE_TYPE::A2RGB10UI_NORM, VK_FORMAT_A2R10G10B10_UNORM_PACK32 },
		{ IMAGE_TYPE::A2RGB10UI, VK_FORMAT_A2R10G10B10_UINT_PACK32 },
		// depth / depth+stencil
		{ (IMAGE_TYPE::UINT |
		   IMAGE_TYPE::CHANNELS_1 |
		   IMAGE_TYPE::FORMAT_16 |
		   IMAGE_TYPE::FLAG_DEPTH), VK_FORMAT_D16_UNORM },
		{ (IMAGE_TYPE::UINT |
		   IMAGE_TYPE::CHANNELS_1 |
		   IMAGE_TYPE::FORMAT_16_8 |
		   IMAGE_TYPE::FLAG_DEPTH |
		   IMAGE_TYPE::FLAG_STENCIL), VK_FORMAT_D16_UNORM_S8_UINT },
		{ (IMAGE_TYPE::FLOAT |
		   IMAGE_TYPE::CHANNELS_1 |
		   IMAGE_TYPE::FORMAT_32 |
		   IMAGE_TYPE::FLAG_DEPTH), VK_FORMAT_D32_SFLOAT },
		{ (IMAGE_TYPE::UINT |
		   IMAGE_TYPE::CHANNELS_2 |
		   IMAGE_TYPE::FORMAT_24_8 |
		   IMAGE_TYPE::FLAG_DEPTH |
		   IMAGE_TYPE::FLAG_STENCIL), VK_FORMAT_D24_UNORM_S8_UINT },
		{ (IMAGE_TYPE::FLOAT |
		   IMAGE_TYPE::CHANNELS_2 |
		   IMAGE_TYPE::FORMAT_32_8 |
		   IMAGE_TYPE::FLAG_DEPTH |
		   IMAGE_TYPE::FLAG_STENCIL), VK_FORMAT_D32_SFLOAT_S8_UINT },
		// BC1 - BC3
		{ IMAGE_TYPE::BC1_RGB, VK_FORMAT_BC1_RGB_UNORM_BLOCK },
		{ IMAGE_TYPE::BC1_RGB_SRGB, VK_FORMAT_BC1_RGB_SRGB_BLOCK },
		{ IMAGE_TYPE::BC1_RGBA, VK_FORMAT_BC1_RGBA_UNORM_BLOCK },
		{ IMAGE_TYPE::BC1_RGBA_SRGB, VK_FORMAT_BC1_RGBA_SRGB_BLOCK },
		{ IMAGE_TYPE::BC2_RGBA, VK_FORMAT_BC2_UNORM_BLOCK },
		{ IMAGE_TYPE::BC2_RGBA_SRGB, VK_FORMAT_BC2_SRGB_BLOCK },
		{ IMAGE_TYPE::BC3_RGBA, VK_FORMAT_BC3_UNORM_BLOCK },
		{ IMAGE_TYPE::BC3_RGBA_SRGB, VK_FORMAT_BC3_SRGB_BLOCK },
		// BC4 - BC5
		{ IMAGE_TYPE::RGTC_RI, VK_FORMAT_BC4_SNORM_BLOCK },
		{ IMAGE_TYPE::RGTC_RUI, VK_FORMAT_BC4_UNORM_BLOCK },
		{ IMAGE_TYPE::RGTC_RGI, VK_FORMAT_BC5_SNORM_BLOCK },
		{ IMAGE_TYPE::RGTC_RGUI, VK_FORMAT_BC5_UNORM_BLOCK },
		// BC6 - BC7
		{ IMAGE_TYPE::BPTC_RGBHF, VK_FORMAT_BC6H_SFLOAT_BLOCK },
		{ IMAGE_TYPE::BPTC_RGBUHF, VK_FORMAT_BC6H_UFLOAT_BLOCK },
		{ IMAGE_TYPE::BPTC_RGBA, VK_FORMAT_BC7_UNORM_BLOCK },
		{ IMAGE_TYPE::BPTC_RGBA_SRGB, VK_FORMAT_BC7_SRGB_BLOCK },
		// PVRTC formats
		// NOTE: not to be confused with PVRTC version 2, here: PVRTC1 == RGB, PVRTC2 == RGBA
		{ IMAGE_TYPE::PVRTC_RGB2, VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGB4, VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGBA2, VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGBA4, VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGB2_SRGB, VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGB4_SRGB, VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGBA2_SRGB, VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG },
		{ IMAGE_TYPE::PVRTC_RGBA4_SRGB, VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG },
	};
	const auto vulkan_format = format_lut.find(image_type & (IMAGE_TYPE::__DATA_TYPE_MASK |
															 IMAGE_TYPE::__CHANNELS_MASK |
															 IMAGE_TYPE::__COMPRESSION_MASK |
															 IMAGE_TYPE::__FORMAT_MASK |
															 IMAGE_TYPE::__LAYOUT_MASK |
															 IMAGE_TYPE::FLAG_NORMALIZED |
															 IMAGE_TYPE::FLAG_DEPTH |
															 IMAGE_TYPE::FLAG_STENCIL |
															 IMAGE_TYPE::FLAG_SRGB));
	if (vulkan_format == end(format_lut)) {
		return {};
	}
	return vulkan_format->second;
}

//! returns the corresponding IMAGE_TYPE for the specified VkFormat, returns emptry if there is no matching format
static inline std::optional<IMAGE_TYPE> image_type_from_vulkan_format(const VkFormat format) {
	static const std::unordered_map<VkFormat, IMAGE_TYPE> format_lut {
		// R
		{ VK_FORMAT_R8_UNORM, IMAGE_TYPE::R8UI_NORM },
		{ VK_FORMAT_R8_SNORM, IMAGE_TYPE::R8I_NORM },
		{ VK_FORMAT_R8_UINT, IMAGE_TYPE::R8UI },
		{ VK_FORMAT_R8_SINT, IMAGE_TYPE::R8I },
		{ VK_FORMAT_R16_UNORM, IMAGE_TYPE::R16UI_NORM },
		{ VK_FORMAT_R16_SNORM, IMAGE_TYPE::R16I_NORM },
		{ VK_FORMAT_R16_UINT, IMAGE_TYPE::R16UI },
		{ VK_FORMAT_R16_SINT, IMAGE_TYPE::R16I },
		{ VK_FORMAT_R16_SFLOAT, IMAGE_TYPE::R16F },
		{ VK_FORMAT_R32_UINT, IMAGE_TYPE::R32UI },
		{ VK_FORMAT_R32_SINT, IMAGE_TYPE::R32I },
		{ VK_FORMAT_R32_SFLOAT, IMAGE_TYPE::R32F },
		// RG
		{ VK_FORMAT_R8G8_UNORM, IMAGE_TYPE::RG8UI_NORM },
		{ VK_FORMAT_R8G8_SNORM, IMAGE_TYPE::RG8I_NORM },
		{ VK_FORMAT_R8G8_UINT, IMAGE_TYPE::RG8UI },
		{ VK_FORMAT_R8G8_SINT, IMAGE_TYPE::RG8I },
		{ VK_FORMAT_R16G16_UNORM, IMAGE_TYPE::RG16UI_NORM },
		{ VK_FORMAT_R16G16_SNORM, IMAGE_TYPE::RG16I_NORM },
		{ VK_FORMAT_R16G16_UINT, IMAGE_TYPE::RG16UI },
		{ VK_FORMAT_R16G16_SINT, IMAGE_TYPE::RG16I },
		{ VK_FORMAT_R16G16_SFLOAT, IMAGE_TYPE::RG16F },
		{ VK_FORMAT_R32G32_UINT, IMAGE_TYPE::RG32UI },
		{ VK_FORMAT_R32G32_SINT, IMAGE_TYPE::RG32I },
		{ VK_FORMAT_R32G32_SFLOAT, IMAGE_TYPE::RG32F },
		// RGB
		{ VK_FORMAT_B10G11R11_UFLOAT_PACK32, IMAGE_TYPE::RG11B10F },
		{ VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, IMAGE_TYPE::RGB9E5F },
		// RGBA
		{ VK_FORMAT_R8G8B8A8_UNORM, IMAGE_TYPE::RGBA8UI_NORM },
		{ VK_FORMAT_R8G8B8A8_SNORM, IMAGE_TYPE::RGBA8I_NORM },
		{ VK_FORMAT_R8G8B8A8_UINT, IMAGE_TYPE::RGBA8UI },
		{ VK_FORMAT_R8G8B8A8_SINT, IMAGE_TYPE::RGBA8I },
		{ VK_FORMAT_R8G8B8A8_SRGB, IMAGE_TYPE::RGBA8UI_NORM | IMAGE_TYPE::FLAG_SRGB },
		{ VK_FORMAT_R16G16B16A16_UNORM, IMAGE_TYPE::RGBA16UI_NORM },
		{ VK_FORMAT_R16G16B16A16_SNORM, IMAGE_TYPE::RGBA16I_NORM },
		{ VK_FORMAT_R16G16B16A16_UINT, IMAGE_TYPE::RGBA16UI },
		{ VK_FORMAT_R16G16B16A16_SINT, IMAGE_TYPE::RGBA16I },
		{ VK_FORMAT_R16G16B16A16_SFLOAT, IMAGE_TYPE::RGBA16F },
		{ VK_FORMAT_R32G32B32A32_UINT, IMAGE_TYPE::RGBA32UI },
		{ VK_FORMAT_R32G32B32A32_SINT, IMAGE_TYPE::RGBA32I },
		{ VK_FORMAT_R32G32B32A32_SFLOAT, IMAGE_TYPE::RGBA32F },
		// BGRA
		{ VK_FORMAT_B8G8R8A8_UNORM, IMAGE_TYPE::BGRA8UI_NORM },
		{ VK_FORMAT_B8G8R8A8_SNORM, IMAGE_TYPE::BGRA8I_NORM },
		{ VK_FORMAT_B8G8R8A8_UINT, IMAGE_TYPE::BGRA8UI },
		{ VK_FORMAT_B8G8R8A8_SINT, IMAGE_TYPE::BGRA8I },
		{ VK_FORMAT_B8G8R8A8_SRGB, IMAGE_TYPE::BGRA8UI_NORM | IMAGE_TYPE::FLAG_SRGB },
		// ABGR
		{ VK_FORMAT_A8B8G8R8_UNORM_PACK32, IMAGE_TYPE::ABGR8UI_NORM },
		{ VK_FORMAT_A8B8G8R8_SNORM_PACK32, IMAGE_TYPE::ABGR8I_NORM },
		{ VK_FORMAT_A8B8G8R8_UINT_PACK32, IMAGE_TYPE::ABGR8UI },
		{ VK_FORMAT_A8B8G8R8_SINT_PACK32, IMAGE_TYPE::ABGR8I },
		{ VK_FORMAT_A2B10G10R10_UNORM_PACK32, IMAGE_TYPE::A2BGR10UI_NORM },
		{ VK_FORMAT_A2B10G10R10_UINT_PACK32, IMAGE_TYPE::A2BGR10UI },
		// ARGB
		{ VK_FORMAT_A2R10G10B10_UNORM_PACK32, IMAGE_TYPE::A2RGB10UI_NORM },
		{ VK_FORMAT_A2R10G10B10_UINT_PACK32, IMAGE_TYPE::A2RGB10UI },
		// depth / depth+stencil
		{ VK_FORMAT_D16_UNORM, (IMAGE_TYPE::UINT |
								IMAGE_TYPE::CHANNELS_1 |
								IMAGE_TYPE::FORMAT_16 |
								IMAGE_TYPE::FLAG_DEPTH) },
		{ VK_FORMAT_D16_UNORM_S8_UINT, (IMAGE_TYPE::UINT |
										IMAGE_TYPE::CHANNELS_1 |
										IMAGE_TYPE::FORMAT_16_8 |
										IMAGE_TYPE::FLAG_DEPTH |
										IMAGE_TYPE::FLAG_STENCIL) },
		{ VK_FORMAT_D32_SFLOAT, (IMAGE_TYPE::FLOAT |
								 IMAGE_TYPE::CHANNELS_1 |
								 IMAGE_TYPE::FORMAT_32 |
								 IMAGE_TYPE::FLAG_DEPTH) },
		{ VK_FORMAT_D24_UNORM_S8_UINT, (IMAGE_TYPE::UINT |
										IMAGE_TYPE::CHANNELS_2 |
										IMAGE_TYPE::FORMAT_24_8 |
										IMAGE_TYPE::FLAG_DEPTH |
										IMAGE_TYPE::FLAG_STENCIL) },
		{ VK_FORMAT_D32_SFLOAT_S8_UINT, (IMAGE_TYPE::FLOAT |
										 IMAGE_TYPE::CHANNELS_2 |
										 IMAGE_TYPE::FORMAT_32_8 |
										 IMAGE_TYPE::FLAG_DEPTH |
										 IMAGE_TYPE::FLAG_STENCIL) },
		// BC1 - BC3
		{ VK_FORMAT_BC1_RGB_UNORM_BLOCK, IMAGE_TYPE::BC1_RGB },
		{ VK_FORMAT_BC1_RGB_SRGB_BLOCK, IMAGE_TYPE::BC1_RGB_SRGB },
		{ VK_FORMAT_BC1_RGBA_UNORM_BLOCK, IMAGE_TYPE::BC1_RGBA },
		{ VK_FORMAT_BC1_RGBA_SRGB_BLOCK, IMAGE_TYPE::BC1_RGBA_SRGB },
		{ VK_FORMAT_BC2_UNORM_BLOCK, IMAGE_TYPE::BC2_RGBA },
		{ VK_FORMAT_BC2_SRGB_BLOCK, IMAGE_TYPE::BC2_RGBA_SRGB },
		{ VK_FORMAT_BC3_UNORM_BLOCK, IMAGE_TYPE::BC3_RGBA },
		{ VK_FORMAT_BC3_SRGB_BLOCK, IMAGE_TYPE::BC3_RGBA_SRGB },
		// BC4 - BC5
		{ VK_FORMAT_BC4_SNORM_BLOCK, IMAGE_TYPE::RGTC_RI },
		{ VK_FORMAT_BC4_UNORM_BLOCK, IMAGE_TYPE::RGTC_RUI },
		{ VK_FORMAT_BC5_SNORM_BLOCK, IMAGE_TYPE::RGTC_RGI },
		{ VK_FORMAT_BC5_UNORM_BLOCK, IMAGE_TYPE::RGTC_RGUI },
		// BC6 - BC7
		{ VK_FORMAT_BC6H_SFLOAT_BLOCK, IMAGE_TYPE::BPTC_RGBHF },
		{ VK_FORMAT_BC6H_UFLOAT_BLOCK, IMAGE_TYPE::BPTC_RGBUHF },
		{ VK_FORMAT_BC7_UNORM_BLOCK, IMAGE_TYPE::BPTC_RGBA },
		{ VK_FORMAT_BC7_SRGB_BLOCK, IMAGE_TYPE::BPTC_RGBA_SRGB },
		// PVRTC formats
		// NOTE: not to be confused with PVRTC version 2, here: PVRTC1 == RGB, PVRTC2 == RGBA
		{ VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGB2 },
		{ VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGB4 },
		{ VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGBA2 },
		{ VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGBA4 },
		{ VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGB2_SRGB },
		{ VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGB4_SRGB },
		{ VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGBA2_SRGB },
		{ VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG, IMAGE_TYPE::PVRTC_RGBA4_SRGB },
	};
	const auto img_type = format_lut.find(format);
	if (img_type == end(format_lut)) {
		return {};
	}
	return img_type->second;
}

//! converts the specified sample count to the Vulkan sample count enum
//! NOTE: if "sample_count" doesn't exactly match a supported sample count, the next lower one is returned
static inline VkSampleCountFlagBits sample_count_to_vulkan_sample_count(const uint32_t sample_count) {
	if (sample_count <= 1) {
		return VK_SAMPLE_COUNT_1_BIT;
	} else if (sample_count < 4) {
		return VK_SAMPLE_COUNT_2_BIT;
	} else if (sample_count < 8) {
		return VK_SAMPLE_COUNT_4_BIT;
	} else if (sample_count < 16) {
		return VK_SAMPLE_COUNT_8_BIT;
	} else if (sample_count < 32) {
		return VK_SAMPLE_COUNT_16_BIT;
	} else if (sample_count < 64) {
		return VK_SAMPLE_COUNT_32_BIT;
	} else {
		return VK_SAMPLE_COUNT_64_BIT;
	}
}

//! returns the Vulkan aspect flags required for the specified image type
static inline VkImageAspectFlags vk_aspect_flags_from_type(const IMAGE_TYPE img_type) {
	VkImageAspectFlags aspect_flags = VK_IMAGE_ASPECT_COLOR_BIT;
	if (has_flag<IMAGE_TYPE::FLAG_DEPTH>(img_type)) {
		aspect_flags = VK_IMAGE_ASPECT_DEPTH_BIT;
		if (has_flag<IMAGE_TYPE::FLAG_STENCIL>(img_type)) {
			aspect_flags |= VK_IMAGE_ASPECT_STENCIL_BIT;
		}
	}
	return aspect_flags;
}

} // namespace fl

#endif // FLOOR_NO_VULKAN
